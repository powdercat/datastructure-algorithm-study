# 정렬 알고리즘

## 1. Quick Sort

대부분의 언어에서 제공하는 정렬 라이브러리는 퀵소트 알고리즘을 바탕으로 만들어져있다.

매 단계마다 pivot 을 정해서 pivot 보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 이동시키는 방식을 이용한다.

* 기본 과정
  1. pivot 을 정한다.
  2. temp array 를 만들고 pivot 을 제외한 나머지 값들을 순회하면서 pivot 보다 작은 값은 temp 에 넣는다.
  3. 그 다음 pivot 을 넣는다.
  4. 그 다음 pivot 보다 큰 값들을 temp 에 넣는다.
  5. temp 를 원래 배열에 덮어쓴다.

위 과정은 temp 라는 추가적인 공간이 필요하다. 추가적인 공간을 사용하지 않는 정렬 = In-place sort 라고 한다.

* 추가적인 공간 없이 정렬하는 과정
  1. pivot 을 정한다.
  2. 제일 왼쪽에는 l, 제일 오른쪽에는 r이라는 포인터 2개를 둔다.
  3. l 은 pivot 보다 큰 값이 나올 때까지 오른쪽으로 이동한다.
  4. r 은 pivot 보다 작거나 같은 값이 나올 때까지 왼쪽으로 이동한다.
  5. l 과 r 을 swap 한다.
  6. l 과 r 이 교차하는 지점에서 pivot 과 r 을 swap 한다.
  7. 그러면 pivot 을 기준으로 왼쪽은 pivot 보다 작은 값, 오른쪽은 pivot 보다 큰 값이 된다. 왼쪽과 오른쪽 배열에서 각각 재귀적으로 1번부터 수행한다.

퀵소트의 시간 복잡도는 O(nlogn) 이다. (최악의 경우 O(n^2) 이다. 리스트가 오름차순이거나 내림차순인 경우 분할이 이루어질 때마다 한쪽만 남기 때문에, 분할이 수행되는 횟수가 n 과 비례한다.)

언어별 라이브러리에서 퀵소트를 사용한다는데, n^2이면 비효율이지 않을까? -> pivot 을 랜덤하게 설정하거나, pivot 후보를 여러개 뽑아서 그 중 중간값을 pivot 으로 사용해서 해소한다.

## 2. Merge Sort

정렬 라이브러리 다음으로 많이 사용되는 알고리즘이다.

재귀적으로 원소들을 나눠 정렬한 후 다시 합치는 방식이다.

1. 리스트를 반으로 나눈다.
2. 나눈 리스트를 각각 정렬한다.
    1. 리스트의 길이가 1이 될 때까지 재귀적으로 나눈다.
    2. 길이가 1이 되면 정렬한다.
3. 정렬된 리스트를 합친다.
    1. 각각 정렬된 리스트의 첫번째 원소를 비교한다.
    2. 둘 중 작은 원소를 결과 리스트에 넣는다.
    3. 반복한다.

머지 소트의 시간 복잡도는 O(nlogn) 이다.

## 3. Counting Sort

각 수의 등장 횟수를 세서 정렬하는 방식이다.

31224353

| 1 | 2 | 3 | 4 | 5 |
|---|---|---|---|---|
| 1 | 2 | 3 | 1 | 1 |

정렬 결과 -> 12233345

하지만, 수의 범위가 어디까지이냐에 따라 메모리를 많이 사용할 수 있다. 그래서 수의 범위가 어느정도 제한되어 있을 때 사용한다.

## 4. Radix Sort

자릿수를 기준으로 정렬하는 방식이다. 카운팅 소트를 응용한 알고리즘이다.

1. 1의 자리를 기준으로 정렬한다.
2. 10의 자리를 기준으로 정렬한다.
3. 반복한다.

라딕스 소트는 메모리를 많이 사용한다. (총 10개의 리스트가 필요하고, 한 리스트는 n 칸의 배열로 만들어야한다.)

시간 복잡도는 O(dn) 이다. (d는 자릿수)

## 5. Bubble Sort

배열의 인접한 두 원소를 비교하며 정렬하는 알고리즘이다.

1. 배열의 끝에서부터 두 원소의 값을 비교해서 왼쪽이 오른쪽보다 크면 swap 한다.
2. 위치를 하나 이동해서 배열의 끝까지 반복한다. = 첫 번째 사이클 완료
3. 위 과정을 배열의 길이만큼 반복한다.

모든 사이클마다 모든 원소를 비교한다.

최악의 경우 모든 사이클마다 모든 원소를 swap 해야한다.

버블 소트의 시간 복잡도는 O(n^2) 이다.

## 6. Selection Sort

1. 배열 중에서 최솟값을 위치를 찾는다.
1. 그 값을 맨 앞에 위치한 값과 교체한다.
1. 맨 처음 위치(이미 정렬된 위치)를 뺀 나머지 배열을 같은 방법으로 교체한다. 반복한다.

모든 사이클마다 모든 원소를 비교한다.

최악의 경우 모든 사이클마다 한 번의 swap 이 이루어진다.

그래도, 선택 정렬의 시간 복잡도는 O(n^2) 이다. (최악, 최선 모두) 

## 7. Insertion Sort

1. i = 2(두 번째 원소)부터 시작한다.
2. 왼쪽에 있는 원소가 해당 원소보다 크면 오른쪽으로 이동시킨다.
3. 이동할 필요가 없을 때까지 왼쪽과 비교 및 이동을 반복한다.
3. i 가 마지막 원소가 될 때까지 반복한다.

필요한 원소들만 비교한다.

삽입 정렬의 시간 복잡도는 O(n^2) 이다. 최선의 경우 O(n) 이다.

## Bubble Sort vs Selection Sort vs Insertion Sort

세 정렬 모두 시간 복잡도는 O(n^2) 이지만 (평균적으로) Insertion Sort > Selection Sort > Bubble Sort 이다.

## 언어별 내장 정렬 함수

실제로는 언어별로 제공하는 정렬 함수를 사용하는 것이 효율적이다.

# 참고 링크

https://www.youtube.com/watch?v=Bor_CRWEIXo

https://www.youtube.com/watch?v=59fZkZO0Bo4

https://www.youtube.com/watch?v=dq5t1woLJMw